# Upgrade from v1.11.x to v2.0.0

In version 2.0.0 of `fury-eks-installer`, we split the vpc-and-vpn module in two, to allow the creation of a VPC and VPN separately, as the latter became optional with the introduction of public EKS clusters.
We also added the possibility to configure the ability to access the Kubernetes API endpoint privately, publicly or both.

## Migrate from the old vpc-and-vpn module to the new vpc and vpn modules

Ensure you have terraform 1.3 or greater installed.

Enter the directory of the terraform module that is using the vpc-and-vpn module

```sh
cd /path/to/module
```

If you have the terraform state stored locally, make a backup of it.

If you have your state saved remotely(eg: on S3), you should skip this step.

```sh
cp /path/to/terraform.tfstate /path/to/terraform.tfstate.bak
```

With that out of the way, you should now rewrite your terraform configuration to use the new vpc and vpn modules, and get rid of the old vpc-and-vpn module.

Once you have done that, you can run `terraform init` to download the new modules, and `terraform plan` to see what changes will be applied, eg:

```sh
terraform init -upgrade
terraform plan -input=false -refresh=true -lock=false -var-file=your.tfvars
```

Now it's time to move the state objects to match the new modules.
Assuming the old module was named "vpc-and-vpn", and the new modules are named "vpc" and "vpn", you can run the following commands to fix the state:

```sh
terraform state mv module.vpc-and-vpn.module.vpc.aws_eip.nat[0] module.vpc[0].module.vpc.aws_eip.nat[0]
terraform state mv module.vpc-and-vpn.module.vpc.aws_internet_gateway.this[0] module.vpc[0].module.vpc.aws_internet_gateway.this[0]
terraform state mv module.vpc-and-vpn.module.vpc.aws_nat_gateway.this[0] module.vpc[0].module.vpc.aws_nat_gateway.this[0]
terraform state mv module.vpc-and-vpn.module.vpc.aws_route_table_association.private[0] module.vpc[0].module.vpc.aws_route_table_association.private[0]
terraform state mv module.vpc-and-vpn.module.vpc.aws_route_table_association.private[1] module.vpc[0].module.vpc.aws_route_table_association.private[1]
terraform state mv module.vpc-and-vpn.module.vpc.aws_route_table_association.private[2] module.vpc[0].module.vpc.aws_route_table_association.private[2]
terraform state mv module.vpc-and-vpn.module.vpc.aws_route_table_association.public[0] module.vpc[0].module.vpc.aws_route_table_association.public[0]
terraform state mv module.vpc-and-vpn.module.vpc.aws_route_table_association.public[1] module.vpc[0].module.vpc.aws_route_table_association.public[1]
terraform state mv module.vpc-and-vpn.module.vpc.aws_route_table_association.public[2] module.vpc[0].module.vpc.aws_route_table_association.public[2]
terraform state mv module.vpc-and-vpn.module.vpc.aws_route_table.private[0] module.vpc[0].module.vpc.aws_route_table.private[0]
terraform state mv module.vpc-and-vpn.module.vpc.aws_route_table.public[0] module.vpc[0].module.vpc.aws_route_table.public[0]
terraform state mv module.vpc-and-vpn.module.vpc.aws_route.private_nat_gateway[0] module.vpc[0].module.vpc.aws_route.private_nat_gateway[0]
terraform state mv module.vpc-and-vpn.module.vpc.aws_route.public_internet_gateway[0] module.vpc[0].module.vpc.aws_route.public_internet_gateway[0]
terraform state mv module.vpc-and-vpn.module.vpc.aws_subnet.private[0] module.vpc[0].module.vpc.aws_subnet.private[0]
terraform state mv module.vpc-and-vpn.module.vpc.aws_subnet.private[1] module.vpc[0].module.vpc.aws_subnet.private[1]
terraform state mv module.vpc-and-vpn.module.vpc.aws_subnet.private[2] module.vpc[0].module.vpc.aws_subnet.private[2]
terraform state mv module.vpc-and-vpn.module.vpc.aws_subnet.public[0] module.vpc[0].module.vpc.aws_subnet.public[0]
terraform state mv module.vpc-and-vpn.module.vpc.aws_subnet.public[1] module.vpc[0].module.vpc.aws_subnet.public[1]
terraform state mv module.vpc-and-vpn.module.vpc.aws_subnet.public[2] module.vpc[0].module.vpc.aws_subnet.public[2]
terraform state mv module.vpc-and-vpn.module.vpc.aws_vpc.this[0] module.vpc[0].module.vpc.aws_vpc.this[0]

terraform state mv module.vpc-and-vpn.aws_eip_association.vpn[0] module.vpn[0].aws_eip_association.vpn[0]
terraform state mv module.vpc-and-vpn.aws_eip.vpn[0] module.vpn[0].aws_eip.vpn[0]
terraform state mv module.vpc-and-vpn.aws_iam_access_key.furyagent module.vpn[0].aws_iam_access_key.furyagent
terraform state mv module.vpc-and-vpn.aws_iam_policy_attachment.furyagent module.vpn[0].aws_iam_policy_attachment.furyagent
terraform state mv module.vpc-and-vpn.aws_iam_policy.furyagent module.vpn[0].aws_iam_policy.furyagent
terraform state mv module.vpc-and-vpn.aws_iam_user.furyagent module.vpn[0].aws_iam_user.furyagent
terraform state mv module.vpc-and-vpn.aws_instance.vpn[0] module.vpn[0].aws_instance.vpn[0]
terraform state mv module.vpc-and-vpn.aws_s3_bucket.furyagent module.vpn[0].aws_s3_bucket.furyagent
terraform state mv module.vpc-and-vpn.aws_security_group_rule.vpn module.vpn[0].aws_security_group_rule.vpn
terraform state mv module.vpc-and-vpn.aws_security_group_rule.vpn_egress module.vpn[0].aws_security_group_rule.vpn_egress
terraform state mv module.vpc-and-vpn.aws_security_group_rule.vpn_ssh module.vpn[0].aws_security_group_rule.vpn_ssh
terraform state mv module.vpc-and-vpn.aws_security_group.vpn module.vpn[0].aws_security_group.vpn
terraform state mv module.vpc-and-vpn.local_file.furyagent module.vpn[0].local_file.furyagent
terraform state mv module.vpc-and-vpn.local_file.sshkeys module.vpn[0].local_file.sshkeys
terraform state mv module.vpc-and-vpn.null_resource.init module.vpn[0].null_resource.init
terraform state mv module.vpc-and-vpn.null_resource.ssh_users module.vpn[0].null_resource.ssh_users
```

Verify the plan once again, making sure the remaining changes you are going to apply shortly are safe.

```sh
terraform plan -input=false -refresh=true -lock=false -var-file=your.tfvars
```

The changes you can expect should look like this:

```sh
  # module.vpn[0].aws_instance.vpn[0] will be updated in-place
  ~ resource "aws_instance" "vpn" {
        id                                   = "i-09e4553cae2b9541d"
      ~ tags                                 = {
          + "Name" = "public-4-vpn-0"
        }
      ~ tags_all                             = {
          + "Name" = "public-4-vpn-0"
        }
    }

  # module.vpn[0].local_file.furyagent will be created
  + resource "local_file" "furyagent" {
      + content              = (sensitive)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "./secrets/furyagent.yml"
      + id                   = (known after apply)
    }

  # module.vpn[0].local_file.sshkeys will be created
  + resource "local_file" "sshkeys" {
      + content              = <<-EOT
            users:
              - name: your-user
                user_id: your-user
        EOT
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "./ssh-users.yml"
      + id                   = (known after apply)
```

If everything looks correct, you can proceed to apply the changes:

```sh
terraform apply -input=false -refresh=true -lock=false -var-file=your.tfvars
```

If everything goes well and you have the terraform state stored locally, you can now clean up the state backups:
do that only when you are sure that the state has been migrated successfully.

```sh
rm terraform.tfstate.*.backup
```
